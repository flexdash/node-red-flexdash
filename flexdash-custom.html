<!-- FlexDash custom node for Node-RED
     Copyright Â©2022 by Thorsten von Eicken, see LICENSE
-->

<script type="module">
  // prepare the general edit tab
  // FIXME: we pretend this node has an output for now, need to figure out how to tweak this...
  flexdash.insert_general_edit("flexdash custom", "fd-tab-general", true)

  // prepare output-related properties if the widget outputs messages
  // FIXME: we pretend this has an output, see above
  let out_prop = {}
  if (true) out_prop = {
    fd_output_topic: { value: null },
    fd_loopback: { value: false },
  }

  // Simple button widget to populate new empty flexdash-custom editors.
  // We have to obfuscate <...> tags 'cause Node-RED will stumble over them.
  const sfc_template = `
[template>
  <v-btn variant="elevated" class="ma-auto" @click="clicked()">
    <span class="label">{{ label }}</span>
  </v-btn>
[/template>

[style scoped>
  .label { color: red; }
[/style>

[script>
export default {
  // Props are the inputs to the widget.
  // They can be set dynamically using Node-RED messages using \`msg.<prop>\`.
  // In a "custom widget" like this one they cannot be set via the Node-RED flow editor:
  // use the default values in the lines below instead.
  props: {
    label: { default: "clickme" }, // text to show inside button
    output: { default: "I was clicked" }, // value to output when clicked
  },

  emits: ['send'], // declare to Vue that this component emits a 'send' event

  // simple methods within the component
  methods: {
    clicked() { // handle the clicking of the button, i.e., the handler for the '@click'
      this.$emit('send', this.output) // emit an event (Vue concept), a 'send' event goes to NR
    },
  },
}
[/script>
`.trimStart().replace(/^\[/gm,"<")

  RED.nodes.registerType("flexdash custom", {
    // properties of the NR node used by NR itself
    category: 'flexdash',
    color: "#F0E4B8",
    inputs: 1,
    outputs: 1, // FIXME: make this dynamic
    icon: "font-awesome/fa-pen", // icon in flow editor
    paletteLabel: "FD custom",

    // node config properties that the user can edit in the flow editor
    defaults: {
      // required fields for FlexDash Widget nodes
      fd_container: {
        type: "flexdash container", value: "", required: true, // grid/panel
        validate: flexdash.validate_widget_container },
      fd_cols: { value: 1, validate(v) { return v>0 && v<=20 } }, // widget width
      fd_rows: { value: 1, validate(v) { return v>0 && v<=100 } }, // widget height
      fd_array: { value: false }, // create array of this widget
      fd_array_max: { value: 10, validate(v) { return v>0 && v<1000} }, // max array size
      ...out_prop, // output-related property
      // name field of Node-RED node (standard)
      name: { value: 'CustomWidget' },
      title: { value: "" },
      
      // fields for the custom node itself
      sfc_source: { value: "", required: true }, // validate: flexdash.validate_sfc_source },
      import_map: { value: {} },
    },

    // Node-RED node label
    label() {
      const lbl = this.name || this.paletteLabel
      return this.fd_array ? lbl+'[ ]' : lbl // indicate whether this is an array-widget 
    },
    labelStyle() { return this.name ? "node_label_italic" : "" },

    oneditprepare() {
      try{
        // select last-used container
        flexdash.select_last_container()
        // display the node ID in the general tab
        $('#nr-node-id').text(this.id || "n/a")

        // set-up source code editor
        this.sfc_editor = RED.editor.createEditor({
          id: 'node-input-sfc_source',
          mode: 'ace/mode/vue',
          value: this.sfc_source || sfc_template,
          minimap: { enabled: false },
        })
        $('.red-ui-editor-text-container').css('flex-grow', 1)

        // add a hook to toggle the visibility of the output-topic field
        // duplicated from flexdash-custom.html, FIXME: make available somehow...
        function toggle_fd_array(is_array) {
          const can = $('.can_output_topic')
          const cannot = $('.cannot_output_topic')
          if (is_array) { can.hide(); cannot.show() } // arrays cannot specify an output topic
          else { can.show(); cannot.hide() } // non-array can
        }
        $('#node-input-fd_array').change(() => {
          toggle_fd_array($('#node-input-fd_array').is(':checked'))
        })
        toggle_fd_array($('#node-input-fd_array').is(':checked'))

        // typed inputs
        $('#node-input-title').typedInput(
            {type:'str',types:['str'],typeField: "#node-input-title-type"})
        $('#node-input-title').typedInput('value', this.title)
        $('#node-input-import_map').typedInput(
            {type:'json',types:['json'],typeField: "#node-input-import_map-type"})
        try { $('#node-input-import_map').typedInput('value', JSON.stringify(this.import_map))
        } catch(e) { }

        // manage tabs
        const tabs = RED.tabs.create({
          id: "fd-tabs", 
          onchange: (tab) => {
            $("#fd-tabs-content").children().hide()
            $("#" + tab.id).show()
            let editor = $("#" + tab.id).find('.monaco-editor').first()
            if(editor.length) {
              //auto focus editor on tab switch
              this.sfc_editor.focus()
            }
            RED.tray.resize()
        }})

        tabs.addTab({ id: "fd-tab-general", label: "General" })
        tabs.addTab({ id: "fd-tab-source", label: "Widget code" })
        tabs.addTab({ id: "fd-tab-config", label: "Config" })
        tabs.activateTab(this.fd_container ? "fd-tab-source" : "fd-tab-general")
        
        // help button in top tray bar - thanks Kevin!
        $('<button type="button" class="ui-button ui-corner-all ui-widget">' +
          '<i class="fa fa-book"></i> help</button>')
          .on('click', () => { RED.sidebar.help.show(this.type) })
          .insertBefore($('#node-config-dialog-cancel'))
      } catch(e) { console.log("fd-custom oneditprepare:", e.stack) }
    },

    oneditsave() { // save the typedInput props so we get the types right
      try {
        flexdash.save_props_edit(this, {}, "fd-tab-config")

        const sfc_source = this.sfc_editor.getValue()
        $('#node-input-sfc_source').val(sfc_source)
        this.dirty = true
        this.sfc_editor.destroy()
        delete this.sfc_editor
      } catch(e) { console.log("fd-custom oneditsave:", e.stack) }
    },

    oneditcancel() {
      this.sfc_editor.destroy()
      delete this.sfc_editor
    },

    oneditresize: function(size) {
      this.sfc_editor.resize()
    },

  })
</script>

<script type="text/html" data-template-name="flexdash custom">
  <div class="form-row">
    <ul id="fd-tabs" style="min-width: 600px; margin-bottom: 20px;"></ul>
  </div>
  <div id="fd-tabs-content"
       style="min-height: calc(100% - 25px); display:flex; flex-direction:column">
    <!-- general properties tab -->
    <div id="fd-tab-general" style="display:none"><!-- dynamically loaded --></div>
    <!-- widget source code -->
    <div id="fd-tab-source" style="display:none; display:flex; flex-direction: column; flex-grow:1">
      <div style="display:flex; flex-direction:column; flex-grow:1;"
           class="node-text-editor" id="node-input-sfc_source" />
      </div>
    </div>
    <!-- config tab -->
    <div id="fd-tab-config" style="display:none">
      <div class="form-row">
        <label for="node-input-title">Title</label>
        <input type="text" id="node-input-title" class="fd-typed-input" placeholder="Custom Widget" />
        <input type="hidden" id="node-input-title-type" />
        <br><small class="fd-indent">Text to display in the widget header. Change using <tt>msg.title</tt>.</small>
      </div>
      <div class="form-row">
        <label for="node-input-import_map">Import Map</label>
        <input type="text" id="node-input-import_map" class="fd-typed-input" placeholder="{}" />
        <input type="hidden" id="node-input-import_map-type" />
        <br><small class="fd-indent">Map of import specifier to URL for resolution.</small>
      </div>
    </div>
  </div>
</script>

<script type="text/markdown" data-help-name="flexdash custom">
Custom widget for FlexDash

This widget allows you to create a custom widget using Vue.js and SFCs (single-file components).
The source code tab should contain a single Vue SFC and will be pre-processed into pure Javascript
and CSS for efficient shipping and import into FlexDash.

## Name and title

Custom widgets have lots of names and titles:
- The 'name' is shown in the nodes in the Node-RED flow editor
- The 'title' is shown in the widget header in FlexDash and the header is omitted if the
  title is empty.
- The SFC source may have a 'name' property and it is ignored...

## Imports

To import modules either URLs or bare module names can be used in import statements in the SFC.
The bare module names are resolved using import maps, which are maps that translate the
bare module names to URLs.

FlexDash itself already loads a number of modules, in particular Vue, Vuetify, uPlot, and
a few other small helper modules.
The import map used for custom widgets is pre-populated with these modules:
- vue: vue.runtime.global.js (the Vue build without the SFC compiler)
- vuetify: all Vuetify components
- uplot: uplot.min.js (The uPlot library)
...

Other modules need to be loaded by URL.
(There currently is no support for loading them from the Node-RED server unless the
static file serving is used, the files are placed there manually and the correct URL used.)
For example, to import the Echarts library with
the vue-echarts wrapper an import map as follows would be needed:

```
{
  "echarts": "https://cdn.jsdelivr.net/npm/echarts@5.4.1/dist/echarts.esm.min.js",
  "vue-echarts": "https://cdn.jsdelivr.net/npm/vue-echarts@6.3.3/dist/index.esm.min.js",
  "vue-demi": "https://cdn.jsdelivr.net/npm/vue-demi@0.13.11/lib/v3/index.mjs",
  "resize-detector": "https://cdn.jsdelivr.net/npm/resize-detector@0.3.0/esm/index.js",
}
```

The important entries here are the last two entries, which are dependencies referenced
in vue-echarts. Those cannot be satisfied other that by providing an import map
(or rewriting the import statement in those sources).
The first two entries could be omitted by using the URLs directly in the import statements in
the SFC source.

Note that import maps are global, so if two custom widgets both define an import for
"echarts" and they don't use the same URL a conflict will result and FlexDash will produce
an error. This is a good thing in that loading big libraries multiple times from different
sources is not goo either...

</script>
