<!-- FlexDash container node for Node-RED
     Copyright Â©2022 by Thorsten von Eicken, see LICENSE
-->

<script type="module">

  function is_panel(node) { return node?.kind?.endsWith("Panel") }
  function has_panel_val(el) { return el?.val()?.endsWith("Panel") }
  function has_grid_val(el) { return el?.val()?.endsWith("Grid") }

  RED.nodes.registerType('flexdash container', {
    category: 'config',

    defaults: {
      name: { value: "" },
      kind: { value: "StdGrid" },
      fd_id: { value: "" }, // flexdash ID of this grid/panel
      fd_children: { value: "" }, // comma-separated list of child node IDs

      // params for grids
      tab: { value: "" },
      weak_tab: { type:"flexdash tab", value:"", required:false, validate: function (v) {
        if (!has_grid_val($('#node-config-input-kind'))) return true // covers ''== undefined' case!
        const configNode = RED.nodes.node(v||this.tab)
        return configNode && (configNode.valid == null || configNode.valid)
      }},
      min_cols: { value: 1, validate: function(v) { return (v>0 && v<=20) } },
      max_cols: { value: 20, validate: function(v) { return (v>0 && v<=20) } },

      // params for panels
      parent: { type:"flexdash container", value:"", required:false, validate: function (v) {
        if (!has_panel_val($('#node-config-input-kind'))) return true // covers ''== undefined' case!
        const configNode = RED.nodes.node(v)
        return configNode && (configNode.valid == null || configNode.valid) && !is_panel(configNode)
      }},
      solid: { value: false },
      cols: { value: 1, validate: function(v) { return v>0 && v<=20 } },
      rows: { value: 1, validate: function(v) { return v>0 && v<=100 } },
    },

    label() { 
      const name = this.name || (this.fd_pos != null ? `#${this.fd_pos+1}` : null)
      if (!name) return 'New grid'
      const parent = RED.nodes.node(is_panel(this) ? this.parent : this.tab)
      const parent_name = parent ? ` < ${parent.label()}` : ""
      return `${this.kind} ${name}${parent_name}`
    },
    //labelStyle() { return this.name ? "node_label_italic" : "" },

    oneditprepare() {
      try {
        console.log("Oneditprepare container", this.id, "tab:", this.tab)
        // console.log("container oneditprepare entered")
        // toggle UI between two alternatives
        function show_if(cond, sel_true, sel_false) {
          if (cond) { $(sel_true).show(); $(sel_false).hide() }
          else { $(sel_true).hide(); $(sel_false).show() }
        }

        // set weak_tab to value of tab, see oneditsave for explanation
        if (this.tab) $(`#node-config-input-weak_tab [value=${this.tab}]`).attr('selected',"")

        // tweak position
        //flexdash.adjust_container_position(is_panel(this) ? 'parent' : 'weak_tab')

        // handle grid/tab toggle buttons
        function select_grid_tab(which) {
          // handle button state
          $(".kind-button-group").removeClass("selected")
          $(`.kind-button-group[kind=${which}]`).addClass("selected")
          $('#node-config-input-kind').val(which)
          // toggle the panel and set the value in the param to be saved
          const is_panel = which.endsWith('Panel')
          show_if(is_panel, "#panel-only", "#grid-only")
          // select the most recent container if we're switching to panel
          if (is_panel && flexdash.last_container) {
            const sel_add = $('#node-config-input-parent [selected]').val() == "_ADD_"
            if (sel_add) {
              $('#node-config-input-parent option').removeAttr("selected")
              $(`#node-config-input-parent [value=${flexdash.last_container}]`).attr('selected',"")
            }
          }
        }
        select_grid_tab(this.kind)
        $(".kind-button-group").on("click", function() {
          select_grid_tab($(this).attr("kind"))
        })

        const label = this.label || this._def.label // !@#$%^&* on create...
        $('#node-config-title').text(label.bind(this)())

        // console.log("FlexDash container prepare", this)
      } catch(e) { console.log("FlexDash container prepare error", e); throw e }
    },

    // oneditsave needs to tweak the HTML inputs to modify stuff, setting values in this is pointless
    oneditsave() {
      try {
        // console.log(`container oneditsave entered, this.weak_tab=${this.weak_tab}, $(weak_tab)=${$('#node-config-input-weak_tab').val()}`)
        // fix-up fields that depend on the kind
        const is_panel = has_panel_val($('#node-config-input-kind'))
        if (is_panel) {
          // avoid panels within panels
          const p = $('#node-config-input-parent [selected]').val()
          if (p == this.id) $('#node-config-input-parent [selected]').val("")
        } else {
          // clear the parent field so we don't depend on some random config node
          $('#node-config-input-parent [selected]').val("")
          $('#node-config-input-parent').removeClass("input-error")
        }

        // switch the flexdash tab ID to a different field so we don't depend on it on export;
        // this is hideous hack... createExportableNodeSet exports config nodes referenced in 
        // params that have a type field. So we move the weak_tab ID to tab and voila, no dependency!
        const weak_tab = $('#node-config-input-weak_tab')
        $('#node-config-input-tab').val(is_panel ? "" : weak_tab.val())
        weak_tab.val("")

        // console.log("FlexDash container save:", Object.assign({}, this))
      } catch(e) { console.log("FlexDash container save error", e); throw e }
    },
  })
</script>

<script type="text/html" data-template-name="flexdash container">
  <h3 id="node-config-title"></h3>
  <div class="form-row">
    <label for="node-config-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-config-input-name" placeholder="Name">
    <small class="fd-indent">Name shown above panel or grid in dashboard. Hidden if left empty.
    </small>
  </div>
  <div class="form-row">
    <label for="kind-span">Container type</label>
    <span class="button-group" id=""kind-span>
      <button type="button" class="red-ui-button toggle kind-button-group" kind="StdGrid"
        >std grid</button
        ><button type="button" class="red-ui-button toggle kind-button-group" kind="ArrayGrid"
        >array grid</button
        ><button type="button" class="red-ui-button toggle kind-button-group" kind="Panel"
        >panel</button>
    </span>
    <small class="fd-indent">A standard grid is the primary container for widgets and panels. It reflows
      its content based on the width of the browser window.
      An array grid is a grid that can repeat its content multiple times.
      A panel can be used within a grid to create a sub-grid in which widgets can be arranged
      at fixed positions without being impacted by the window width.
    </small>
  </div>
  
  <!-- Fields specific to grids -->
  <div id="grid-only" style="display: none">
    <div class="form-row">
      <label for="node-config-input-weak_tab">Tab</label>
      <input type="text" id="node-config-input-weak_tab">
      <small class="fd-indent">Tab in which the grid is shown.</small>
    </div>
    <div class="form-row">
      <label for="node-config-input-min_cols">Min columns</label>
      <input type="number" id="node-config-input-min_cols" style="width: 6em"><br>
      <label for="node-config-input-max_cols">Max columns</label>
      <input type="number" id="node-config-input-max_cols" style="width: 6em"><br>
      <small class="fd-indent">Minimum and maximum number of grid columns shown in the grid.
        This can be used to constrain the reflow based on window width.</small>
    </div>  
  </div>
  
  <!-- Fields specific to array grids -->
  <div id="array-grid-only" style="display: none">
    <div class="form-row">
      <label for="node-config-input-repeat">Repeat</label>
      <input type="number" id="node-config-input-repeat"><br>
      <small class="fd-indent">Number of repeats (1..N), i.e. array size.
        To send data to widgets in the array grid, use `msg.array_ix = [0-based-index]`.
        The number of repeats can be controlled dynamically using the fd_control node, and
        instead of a numeric array index it is also possible to use a key.</index>
      </small>
    </div>  
  </div>

  <!-- Fields specific to panels -->
  <div id="panel-only" style="display: none">
    <div class="form-row">
      <label for="node-config-input-parent">Containing grid</label>
      <input type="text" id="node-config-input-parent">
      <small class="fd-indent">Grid in which the panel is shown.</small>
    </div>  
    <div class="form-row">
      <label for="node-config-input-solid">Solid</span></label>
      <input type="checkbox" id="node-config-input-solid" />
      <small class="fd-indent">A solid panel looks like a single widget and the widgets
        within it are rendered without borders. A non-solid panel looks like a sub-grid and
        the widgets it contains are rendered with their usual borders.</small>
    </div>
    <div class="form-row">
      <label for="node-config-input-rows">Rows</label>
      <input type="number" id="node-config-input-rows" style="width: 6em"><br>
      <label for="node-config-input-cols">Cols</label>
      <input type="number" id="node-config-input-cols" style="width: 6em"><br>
      <small class="fd-indent">Number of grid rows and columns occupied by the panel.</small>
    </div>
  </div>

  <!-- hidden fields -->
  <input type="hidden" id="node-config-input-kind">
  <input type="hidden" id="node-config-input-fd_id">
  <input type="hidden" id="node-config-input-fd_children">
  <input type="hidden" id="node-config-input-tab">

</script>

<script type="text/html" data-help-name="flexdash container">
  <p>Represents a tab, grid, or panel in FlexDash</p>
</script>
